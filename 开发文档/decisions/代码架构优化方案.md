# 代码架构优化方案

## 目标
**代码极简但功能全面**：通过模块化重构，将 4200 行旧代码重构为清晰的组件化架构，同时保持所有功能完整。

## 设计原则
1. **单一职责原则**：每个模块只做一件事
2. **关注点分离**：数据、逻辑、UI 分离
3. **组件化思维**：可复用、可测试
4. **渐进式迁移**：逐步重构，不影响现有功能

## 架构设计

### 现代化分层架构（推荐）

```
┌─────────────────────────────────────────┐
│           Presentation Layer            │  表现层
│  ┌──────────┐  ┌──────────┐  ┌────────┐│
│  │ MetricCard│  │FilterPanel│  │TabNav │││  组件层
│  └──────────┘  └──────────┘  └────────┘│
├─────────────────────────────────────────┤
│            Application Layer            │  应用层
│  ┌──────────────────────────────────┐  │
│  │          App.js                   │  │  状态管理 + 协调
│  │  - filterState                    │  │
│  │  - currentDimensions              │  │
│  │  - handleFilterChange()           │  │
│  └──────────────────────────────────┘  │
├─────────────────────────────────────────┤
│             Service Layer               │  服务层
│  ┌────────────┐  ┌──────────────────┐ │
│  │WorkerService│  │  ChartService    │ │
│  └────────────┘  └──────────────────┘ │
├─────────────────────────────────────────┤
│             Domain Layer                │  领域层
│  ┌──────────────────────────────────┐  │
│  │      data.worker.js              │  │  数据处理 + 聚合
│  │  - processData()                  │  │
│  │  - applyFilters()                 │  │
│  │  - getDimensionValues()           │  │
│  └──────────────────────────────────┘  │
└─────────────────────────────────────────┘
```

### 数据流设计（单向数据流）

```
User Action
    ↓
Component Event
    ↓
App.handleXXX()  ← 状态管理中心
    ↓
Service Layer (API/Worker)
    ↓
Domain Layer (数据处理)
    ↓
App State Updated
    ↓
Components Re-render
```

## 重构计划

### Phase 1: 基础设施完善（已完成 70%）
- [x] EventBus 事件总线
- [x] WorkerService 封装
- [x] 基础组件（MetricCard, FilterPanel, TabNavigation）
- [ ] ChartService 完善（当前仅占位符）
- [ ] StateManager 状态管理（可选：考虑引入轻量级状态库）

### Phase 2: 图表渲染层迁移（核心任务）
**目标**：将 dashboard.js 中 2000+ 行图表代码迁移到 ChartService

#### 2.1 ChartService 架构设计
```javascript
// js/services/ChartService.js
class ChartService {
    constructor() {
        this.charts = new Map();  // 缓存 echarts 实例
        this.chartConfigs = new Map();  // 缓存配置
    }

    // 核心方法
    renderChart(tabName, dimension, data) {
        const chartRenderer = this.getChartRenderer(tabName);
        return chartRenderer(dimension, data);
    }

    getChartRenderer(tabName) {
        const renderers = {
            overview: this.renderOverviewChart.bind(this),
            premium: this.renderPremiumChart.bind(this),
            cost: this.renderCostChart.bind(this),
            loss: this.renderLossChart.bind(this),
            expense: this.renderExpenseChart.bind(this)
        };
        return renderers[tabName];
    }

    // 具体图表渲染方法
    renderOverviewChart(dimension, data) { /* ... */ }
    renderPremiumChart(dimension, data) { /* ... */ }
    renderCostChart(dimension, data) { /* ... */ }
    renderLossChart(dimension, data) { /* ... */ }
    renderExpenseChart(dimension, data) { /* ... */ }

    // 通用配置方法
    getBaseChartConfig() { /* ... */ }
    applyChartTheme(config) { /* ... */ }
}
```

#### 2.2 迁移步骤
1. 从 dashboard.js 提取 `renderXXXChart()` 方法
2. 重构为纯函数（输入：dimension + data，输出：echarts config）
3. 移除对 `this.data` 的直接依赖
4. 单元测试保证兼容性
5. 逐个 tab 迁移并验证

### Phase 3: 筛选器逻辑优化（部分完成）
- [x] FilterPanel 组件化
- [ ] 实现 13 维度筛选器（参考 UI_UX_Redesign.md）
- [ ] 级联筛选逻辑
- [ ] 筛选器状态持久化

### Phase 4: 状态管理统一化
**当前问题**：状态散落在 Dashboard 对象和 App 对象中

**解决方案**：统一到 App.js
```javascript
// js/core/App.js
class App {
    constructor() {
        // 集中化状态管理
        this.state = {
            // 数据状态
            rawData: null,
            aggregatedData: null,

            // 筛选状态
            filterState: {
                time: { year: null, weekStart: 1, weekEnd: 52 },
                drill: { applied: [], draft: {} }
            },

            // UI 状态
            currentTab: 'overview',
            currentDimensions: { /* ... */ },
            currentSubTab: { loss: 'bubble' },

            // 元数据
            metadata: {
                organizationMode: 'branch',
                availableYears: [],
                // ...
            }
        };
    }

    // 状态更新方法（遵循不可变原则）
    setState(updates) {
        this.state = { ...this.state, ...updates };
        this.emit('stateChanged', this.state);
    }

    // 业务逻辑方法
    async applyFilters(newFilters) {
        this.setState({ filterState: newFilters });
        const filteredData = await this.workerService.applyFilters(newFilters);
        this.setState({ aggregatedData: filteredData });
    }
}
```

### Phase 5: 清理遗留代码
- [ ] 删除 dashboard.js（功能完全迁移后）
- [ ] 删除 static-report-generator.js（已被 WorkerService 替代）
- [ ] 清理 index.html 中的内联脚本
- [ ] 移除未使用的 CSS 规则

## 代码组织规范

### 文件命名
```
PascalCase  : 类文件 (App.js, EventBus.js, MetricCard.js)
camelCase   : 工具函数 (formatters.js, constants.js)
kebab-case  : 配置文件 (dashboard.css)
```

### 模块导入顺序
```javascript
// 1. 外部依赖
import echarts from 'echarts';

// 2. 核心模块
import EventBus from './core/EventBus.js';
import App from './core/App.js';

// 3. 服务层
import WorkerService from './services/WorkerService.js';

// 4. 组件
import MetricCard from './components/MetricCard.js';

// 5. 工具
import { formatRate } from './utils/formatters.js';
import { EVENTS } from './utils/constants.js';
```

### 注释规范
```javascript
/**
 * JSDoc 风格注释
 * @param {string} tabName - Tab 名称
 * @param {object} data - 数据对象
 * @returns {Promise<object>} 处理后的数据
 */
async function processTabData(tabName, data) {
    // 单行注释：简要说明逻辑
    const filteredData = data.filter(/* ... */);

    /*
     * 多行注释：复杂逻辑说明
     * 这里处理了 XXX 场景
     */
    return processedData;
}
```

## 性能优化策略

### 1. 组件缓存
```javascript
// 缓存 echarts 实例，避免重复创建
this.charts = new Map();

renderChart(containerId, config) {
    let chart = this.charts.get(containerId);
    if (!chart) {
        chart = echarts.init(document.getElementById(containerId));
        this.charts.set(containerId, chart);
    }
    chart.setOption(config);
}
```

### 2. 防抖/节流
```javascript
// 防抖：用户停止操作后才执行
this.debouncedFilter = debounce(this.applyFilters, 300);

// 节流：限制执行频率
this.throttledResize = throttle(this.handleResize, 100);
```

### 3. 虚拟滚动（未来）
如果数据量巨大（如机构列表超过 100 个），考虑引入虚拟滚动。

## 测试策略

### 单元测试
```javascript
// tests/utils/formatters.test.js
describe('formatRate', () => {
    test('formats rate with 2 decimals by default', () => {
        expect(formatRate(94.567)).toBe('94.57');
    });

    test('handles null/undefined gracefully', () => {
        expect(formatRate(null)).toBe('--');
    });
});
```

### 集成测试
```javascript
// tests/integration/filter-workflow.test.js
describe('Filter Workflow', () => {
    test('applying filters updates all charts', async () => {
        const app = new App();
        await app.init(mockData, mockWorker);

        await app.applyFilters({ drill: { applied: [{ dimension: 'org', values: ['天府'] }] } });

        expect(app.state.aggregatedData).toBeDefined();
        // 验证图表已更新
    });
});
```

## 代码质量指标

### 目标
- [ ] 平均函数行数 < 30 行
- [ ] 圈复杂度 < 10
- [ ] 文件行数 < 300 行
- [ ] 测试覆盖率 > 70%
- [ ] ESLint 零警告
- [ ] TypeScript 迁移（可选）

## 迁移时间表

### 2 周冲刺计划
**Week 1**：
- Day 1-2: ChartService 架构设计
- Day 3-5: 迁移 overview + premium 图表
- Day 6-7: 迁移 cost + loss 图表

**Week 2**：
- Day 8-9: 迁移 expense 图表
- Day 10-11: 状态管理统一化
- Day 12-13: 删除旧代码，测试验证
- Day 14: 代码审查 + 文档更新

## 风险与缓解

### 风险 1：重构引入 Bug
**缓解**：
- 渐进式迁移，每个 tab 单独验证
- 保留旧代码，使用 feature flag 切换
- 完善测试覆盖

### 风险 2：性能下降
**缓解**：
- 性能基准测试
- 关键路径性能监控
- 必要时回滚

### 风险 3：工期延误
**缓解**：
- 优先迁移核心功能
- 非核心功能可延后
- 每日进度跟踪

## 成功标准

✅ 代码量减少 50% 以上（从 4200 行 → < 2000 行）
✅ 功能零损失（所有现有功能正常工作）
✅ 可维护性提升（新增功能时间减少 50%）
✅ 性能不下降（首屏加载 < 3s，图表渲染 < 500ms）
✅ 代码质量达标（ESLint 通过，测试覆盖率 > 70%）

## 参考资料
- [Clean Code - Robert C. Martin](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882)
- [Refactoring - Martin Fowler](https://refactoring.com/)
- [React Design Patterns](https://www.patterns.dev/)（虽然项目用 Vanilla JS，但设计模式通用）
